%% Finding a 2D SSM for a von K치rm치n beam
%
%
% This is an example of how to reconstruct a slow 2D SSM of a mechanical system
% using synthetic measurements of a scalar quantity. In this example, we measure
% the full phase space of a clamped-clamped von K치rm치n beam. [1]
%
%
%
% [1] Jain, S., Tiso, P. & Haller, G. (2017). Exact Nonlinear Model Reduction
% for a von Karman beam: Slow-Fast Decomposition and Spectral Submanifolds. Journal
% of Sound and Vibration. 423. 10.1016/j.jsv.2018.01.049.

clearvars
close all
clc
%% Example setup
%
%
% The $N$-degree of freedom dynamical system is of the form
%
% $$\mathbf{M\ddot{q}} + \mathbf{C\dot{q}} + \mathbf{Kq} + \mathbf{f}(\mathbf{q},\mathbf{\dot{q}})
% = \mathbf{0}$$
%
% where $\mathbf{f}=\mathcal{O}(|\mathbf{q}|^2,|\mathbf{\dot{q}}|^2,|\mathbf{q}||\mathbf{\dot{q}}|)$
% represents the nonlinearities and $\mathbf{M}$, $\mathbf{C}$, and $\mathbf{K}$
% are the $N\times N$ mass, stiffness, and damping matrices, respectively.
%
% We rewrite the system in first-order form as
%
% $$\mathbf{\dot{x}} = \mathbf{A}\mathbf{x} + \mathbf{G}(\mathbf{x}) = \mathbf{F}(\mathbf{x})$$
%
% with
%
% $\mathbf{x}=\left[\begin{array}{c}\mathbf{q}\\\dot{\mathbf{q}}\end{array}\right],\quad\mathbf{A}=\left[\begin{array}{cc}\mathbf{0}
% & \mathbf{I}\\-\mathbf{M}^{-1}\mathbf{K} & -\mathbf{M}^{-1}\mathbf{C} \end{array}\right],\quad\mathbf{G}(\mathbf{x})=\left[\begin{array}{c}
% \mathbf{0} \\ -\mathbf{M}^{-1}\mathbf{f}(\mathbf{x})\end{array}\right]$.
%
%

nElements = 12;
[M,C,K,fnl,f_0,outdof, PlotFieldonDefMesh] = build_model(nElements);
n = size(M,1);    % mechanical dofs (axial def, transverse def, angle)
[F, lambda,Vmodel] = functionFromTensors(M, C, K, fnl);
%% Generation of Synthetic Data
%
%
% Having set up the dynamics of the problem, we now move on to generate synthetic
% data, which will be used to fit a parametrisation of the manifold. We will divide
% the data into a training set, for model fitting, and a test set, for validation.
% In this case we will use one trajectory as the training set and another one
% as the test set.

nTraj = 2;
indTest = [1];
indTrain = setdiff(1:nTraj, indTest);
%%
%
%
% We now set the initial conditions for the trajectories. Our test set trajectory
% is initialized by applying a point load at the beam tip, which is removed at
% the start of the simulation. For the training trajectory, we use a different
% point load. We expect the trajectories to eventually converge onto a slow 2D
% manifold, which will be identified and used to reduce the system dynamics.

loadvector = zeros(n,nTraj);
loadvector(outdof,1) = -1.75; % point load, [N]
loadvector(outdof,2) = -2; % point load, [N]
w0 = -K\loadvector(:,1); % linear initial guess
IC = zeros(2*n,nTraj);
options = optimoptions('fsolve', 'MaxFunctionEvaluations', 200*n, 'Display', 'off');
for iLoad = 1:nTraj
    f_eq = @(w)([zeros(n) M]*F(0,[w; zeros(n,1)]) + loadvector(:,iLoad));
    [w0, ~, exitflag, output] = fsolve(f_eq, w0, options);
    if exitflag <= 0
        error('Warning: No solution found for loading configuration')
    end
    IC(:,iLoad) = [w0; zeros(n,1)];
end
figure; PlotFieldonDefMesh(w0,150)

%%
%
%
% The data is generated by time-integration of the right-hand side of the system.
% In this case we are observing the full phase space. We also make sure 
% that the data is sampled with a sufficiently high frequency.

new_meas = 0;
observable = @(x) x;
if new_meas == 1
    tEnd = 30;
    nSamp = fix(50 * tEnd * abs(imag(lambda(1))) / (2*pi));
    dt = tEnd/(nSamp-1);
    tic
    xData = integrateTrajectories(F, observable, tEnd, nSamp, nTraj, IC);
    toc
    DataInfo = struct('nElements',nElements,'loadvector',loadvector);
    FullTrajectories = xData;
    save('data_VKcc.mat','DataInfo','FullTrajectories')
else
    load data_VKcc.mat
    if nElements ~= DataInfo.nElements
       error('The loaded data comes from a model with a different number of elements.') 
    end
    xData = cell(size(FullTrajectories,1),2);
    for ii = 1:size(FullTrajectories,1)
        xData{ii,1} = FullTrajectories{ii,1}; 
        xData{ii,2} = observable(FullTrajectories{ii,2});
    end
    tEnd = FullTrajectories{1,1}(end);
end
%
figure(28); clf;
plot(xData{1,1}, xData{1,2}(outdof,:), xData{2,1}, xData{2,2}(outdof,:), ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); ylabel('$u \, [$m$]$','Interpreter','latex');
legend({'trajectory 1', 'trajectory 2'})
set(gca,'fontname', 'helvetica'); set(gca,'fontsize', 18); title('Generated data')

SSMDim = 2;
yData = coordinates_embedding(xData, SSMDim);
%% Data filtering
%
%
% We need to make sure that the data that we use to identify the slow manifold
% lies close to it. We can do this by plotting a spectrogram of the beam tip displacement
% $u$. In general, there may be many vibratory modes present at first, but the
% faster ones quickly die out.

showSpectrogram(yData(indTrain,:), outdof);
ylim([0,50])
%%
%
%
% We plot the middle point displacement  over time for closer inspection.

plot(xData{1,1}, xData{1,2}(outdof,:), ...
     xData{2,1}, xData{2,2}(outdof,:), ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); ylabel('$u \, [$m$]$','Interpreter','latex');
legend({'trajectory 1', 'trajectory 2'})
set(gca,'fontname', 'helvetica'); set(gca,'fontsize', 18); title('Generated data')
%%
%
%
% Next, we use the information from the spectrogram and plot to remove the first
% part of the training data. After the first few oscillations have passed, there
% is one dominant mode left in the frequency spectrum. In this case, faster modes
% die out very quickly, so we can use almost all of the data. We must however
% remove the first transient to fulfill the assumption that trajectories lie close
% to the SSM. We keep only the time interval |sliceInt|.

sliceInt = [1, tEnd];
yDataTrunc = sliceTrajectories(yData, sliceInt);
%% Datadriven manifold fitting
%
%
% The measured trajectories are assumed to lie close to a two-dimensional manifold
% that is tangent at the origin to the eigenspace corresponding to the slowest
% pair of eigenvalues. We now want to fit a polynomial of order $M$ to the data
% points to approximate the manifold. Here we use a graph style parametrization,
% meaning that the manifold is parametrized using coordinates in the computed
% eigenspace $V_e$. This excludes the possibility of folds on the manifold (however,
% if necessary we may circumvent this problem by increasing the dimensionality
% of the observed space).
%
%
%
% We seek the $2N\times m_M$ polynomial coefficient matrix $H$ of the manifold
% on the form
%
% $y = V_e V_e^\top y + H \phi_{m,2:M}(V_e^\top y) $,
%
% where the function $\phi_{m,2:M}(q)$ computes a vector of all $m_M$ monomials
% from orders 2 up to $M$ of an $m$-vector $q$. This optimization problem amounts
% to minimizing a cost function computed from the measured data $y_k$,
%
% $$C_r(V_e,H) = \sum_{k=1}^N ||y_k - V_eV_e^\top y_k - H\phi_{m,2:M}(V_e^\top
% y_k) ||$$
%
% to find $H$ and the $2N\times 2$ eigenspace matrix $V_e$, under the constraints
% that $V_e^\top H=0$ and $V_e^\top V_e = I$. The minimization is performed with
% the Matlab function |fmincon| in |IMparametrization|.
%
% Since we are observing the phase space, we used some knowledge from the
% model by prescribing $$V_e$$ as the eigenspace of the slow mode. 

SSMOrder = 3;
[V, SSMFunction, mfdInfo] = IMparametrization(yDataTrunc(indTrain,:), SSMDim, SSMOrder,[real(Vmodel(:,1)) imag(Vmodel(:,1))]);
%% Plot and validation
%
%
% Now that we have computed the eigenspace of the manifold, we pass to the reduced
% coordinates $y$ by projecting all trajectories onto the eigenspace.

etaData = getProjectedTrajs(yData, V);
etaDataTrunc = getProjectedTrajs(yDataTrunc, V);
%%
%
%
% We plot the test and training set trajectories projected onto the plane. After
% all initial transients die out, the trajectories seem to be confined to a slowly
% decaying oscillating eigenmode. This is the data we will use to train our reduced
% order model for the dynamics. In these coordinates, the initial transient that
% we removed is visible as irregular high-frequency oscillations in the first
% revolution.

plotReducedCoords(etaData);
legend({'Test set trajectory', 'Training set trajectory'})
%%
%
%
% Furthermore, we draw the middle point component of the manifold shape along with
% the trajectory from the training set.

plotSSMWithTrajectories(yDataTrunc(indTrain,:), SSMFunction, outdof+2, V, 10, 'SSMDimension', SSMDim)
view(-100,20); zlabel('$u \, [$m$]$','Interpreter','latex')
%% Reduced order model
%
%
% We compute a model for the reduced dynamics with the truncated training data
% projected onto the manifold. The function |IMdynamics_flow| fits a polynomial
% map
%
% $$\dot{\eta} = W_r \phi(\eta)$$
%
% where $\phi(\eta)$ again computes a vector of all monomials of $\eta$, and
% $W_r$ is a matrix of polynomial coefficients.
%
% We are also specifying that we want the reduced dynamics on a normal form,
% and seek the Taylor expansion of a map $N$ fulfilling
%
% $$\dot{z} = N(z) \approx Dz + W_n\phi(z)$$
%
% with $D$ a diagonal matrix and $W_n$ containing coefficients for the near-resonant
% nonlinear terms, after a near-identity change of coordinates
%
% $$z = T^{-1}(\eta) \approx \eta + W_t \phi(\eta)$$
%
% with $W_t$ containing the coefficients for the nonlinear terms of the coordinate
% change.
%
% Since we are observing the phase space, we used some knowledge from the
% model by prescribing the linearized, exact eigenvalues. 

% From the modal coordinates to the orthogonal representation of the linear
% part
Cchange = V'*Vmodel(:,1:SSMDim);
R1 = real(Cchange*diag(lambda(1:SSMDim))*inv(Cchange));

ROMOrder = 7;
[~,Tinv,N,T,NormalFormInfo] = IMdynamics_flow(etaDataTrunc(indTrain,:),'R_PolyOrd', 1,'R_coeff',R1,'N_PolyOrd', ROMOrder, 'style', 'normalform','MaxIter',3e3);


%
% We transform the truncated initial condition of our test trajectory according
% to the obtained change of coordinates, and integrate our reduced order evolution
% rule to predict the development of the trajectory.

zData = transformComplex(Tinv, etaDataTrunc);
[zRec, yRecNormal] = integrateFlows(N, zData, @(q) SSMFunction(T(q)));
etaRecNormal = transformComplex(T, zRec);
% Evaluation of reduced dynamics
%
%
% The error RRMSE is computed as the average distance of the predicted trajectory
% to the measured one in the full state space.

[reducedTrajDist, fullTrajDist] = computeRecDynErrors(etaRecNormal, yRecNormal, etaDataTrunc, yDataTrunc);
RRMSE_normal = mean(fullTrajDist(indTest))
%
%
%
% We plot the true test set trajectory in the reduced coordinates and compare
% it to the prediction.

plotReducedCoords(etaDataTrunc(indTest(1),:), etaRecNormal(indTest(1),:))
legend({'Test set (truncated)', 'Prediction'})
%
%
%
% We also plot the measured and predicted tip displacement. The reduced model
% seems to do well on previously unseen data, provided that it is close to the
% 2D manifold.

plotReconstructedTrajectory(yData(indTest(1),:), yRecNormal(indTest(1),:), outdof, 'm')
legend({'Test set', 'Prediction'}); 
xlabel('$t \, [$s$]$','Interpreter','latex'); ylabel('$u \, [$m$]$','Interpreter','latex')
%%
%
%
% Finally we compare the estimated eigenvalues of the continuous evolution function
% to the ones computed from the linearized system.

DSEigenvalues = lambda(1:SSMDim)
normalFormEigenvalues = computeEigenvaluesFlow(NormalFormInfo)
%% Backbone curves
%
%
% With the knowledge of the coefficients of the normal form, we extract backbone
% curves for the instantaneous damping and frequency.

N_info = NormalFormInfo.N;
[damp, freq] = polarnormalform(N_info.coeff, N_info.exponents, N_info.phi);
figure
maxRho = abs(zData{indTest(1),2}(1,1));
[dmp, frq, amp, rho_plot] = backbonecurves(damp, freq, SSMFunction, T, outdof, maxRho,'norm');
subplot(121); ylabel('$u \, [$m$]$','Interpreter','latex')
subplot(122); ylabel('$u \, [$m$]$','Interpreter','latex')
%%
% The data-driven model can now be used for forced response predictions. We
% first compute forced response using the full model with SSMTool that are used,
% after calibration, to validate the predictions of our data-driven reduced-order
% model.

% Compute with SSMTool
f_full = 5e-4*[4 8 12];
f_vec = loadvector(:,1)/max(abs(loadvector(:,1)));
w_span = [30 37];
FRC_full = getFRC_full(M, C, K, fnl, f_vec, f_full, outdof, w_span, ROMOrder); close all

% Calibration based on the maximal amplitude response of a validation FRC
idx_f_full = 1;
amp_max = max(FRC_full.(['F' num2str(idx_f_full)]).Amp);
[~,pos] = min(abs(amp-amp_max));
rho_max = rho_plot(pos);
f_red = abs(damp(rho_max)*rho_max) * f_full/f_full(idx_f_full);
ratio_force_data_full = f_red/f_full(idx_f_full);

% Compute with data-driven model
ddROM = struct('Dim',SSMDim,'Param',SSMFunction,'CCtoNormal',Tinv,'ReducedDynNormal',N,'CCfromNormal',T);
FRC_data = getFRC_ddROM(ddROM,f_red,w_span,outdof);

%%
% Plot
figure(100); clf; hold on; grid on; box on; colors = colororder;
plot(frq, amp,'k','DisplayName', 'Backbone - SSMlearn')% $\mathcal{O}(7)$
for ii = 1:length(f_full)
    freq_i = FRC_full.(['F' num2str(ii)]).Freq;
    amp_i  = FRC_full.(['F' num2str(ii)]).Amp;
    stab_i = FRC_full.(['F' num2str(ii)]).Stab;
    [~,pos] = find(abs(diff(stab_i))==1);
    if isempty(pos)==1
        h_i = plot(freq_i,amp_i,'Color',colors(1,:),'Linewidth',2,...
            'DisplayName', 'FRC stable - SSMtool');
    else
        h_i = plot(freq_i(1:pos(1)),amp_i(1:pos(1)),'Color',colors(1,:),'Linewidth',2,...
            'DisplayName', 'FRC stable - SSMtool');
        if length(pos)>1
            h_ii = plot(freq_i(pos(1)+1:pos(2)),amp_i(pos(1)+1:pos(2)),'--','Color',colors(1,:),'Linewidth',2,...
                'DisplayName', 'FRC unstable -  SSMtool');
            h_iii = plot(freq_i(pos(2)+1:end),amp_i(pos(2)+1:end),'Color',colors(1,:),'Linewidth',2);
            h_iii.Annotation.LegendInformation.IconDisplayStyle = 'off';
            
        else
            h_ii = plot(freq_i(pos(1)+1:end),amp_i(pos(1)+1:end),'--','Color',colors(1,:),'Linewidth',2,...
                'DisplayName', 'FRC unstable -  SSMTool');
        end
        if ii~= 1; h_i.Annotation.LegendInformation.IconDisplayStyle = 'off';
            h_ii.Annotation.LegendInformation.IconDisplayStyle = 'off'; end
    end
end
for ii = 1:length(f_red)
    freq_i = FRC_data.(['F' num2str(ii)]).Freq;
    amp_i  = FRC_data.(['F' num2str(ii)]).Amp;
    stab_i = FRC_data.(['F' num2str(ii)]).Stab;
    [~,pos] = find(abs(diff(stab_i))==1);
    if isempty(pos)==1
        h_i = plot(freq_i,amp_i,'Color',colors(2,:),'Linewidth',2,...
            'DisplayName', 'FRC stable - SSMlearn');
    else
        h_i = plot(freq_i(1:pos(1)),amp_i(1:pos(1)),'Color',colors(5,:),'Linewidth',2,...
            'DisplayName', 'FRC stable - SSMlearn');
        h_ii = plot(freq_i(pos(1)+1:pos(2)),amp_i(pos(1)+1:pos(2)),'--','Color',colors(5,:),'Linewidth',2,...
            'DisplayName', 'FRC unstable - SSMlearn');
        h_iii = plot(freq_i(pos(2)+1:end),amp_i(pos(2)+1:end),'Color',colors(5,:),'Linewidth',2);
        h_iii.Annotation.LegendInformation.IconDisplayStyle = 'off';
        if ii~= 1; h_i.Annotation.LegendInformation.IconDisplayStyle = 'off';
            h_ii.Annotation.LegendInformation.IconDisplayStyle = 'off'; end
    end
end
xlabel('$\Omega \, [$rad/s$]$','Interpreter','latex')
ylabel('$u \, [$m$]$','Interpreter','latex')
set(gca,'fontname','helvetica')
set(gca,'fontsize',18)
legend('location','NW')
xlim([w_span(1)+1 w_span(2)-1])

%% Numerical Integration
if new_meas == 1
    w_0 = 32;
    Npers = 50;
    f_veci = M\f_vec;
    tic
    jj = 1
    F_force = @(t,x,w) F(t,x) + [zeros(n,1); f_veci*f_full(jj)*cos(w*t)];
    [~,x_sim] = ode23tb(@(t,x) F_force(t,x,w_0),[0 Npers*2*pi/w_0], zeros(2*n,1));
    jj = 2
    F_force = @(t,x,w) F(t,x) + [zeros(n,1); f_veci*f_full(jj)*cos(w*t)];
    [~,x_sim] = ode23tb(@(t,x) F_force(t,x,w_0),[0 Npers*2*pi/w_0], transpose(x_sim(end,:)));
    jj = 3
    F_force = @(t,x,w) F(t,x) + [zeros(n,1); f_veci*f_full(jj)*cos(w*t)];
    [t_sim,x_sim] = ode23tb(@(t,x) F_force(t,x,w_0),[0 Npers*2*pi/w_0], transpose(x_sim(end,:)));
    t_sim = t_sim'; x_sim = x_sim';
    toc
    figure
    plot(t_sim,x_sim(outdof,:))
    
    [t_sim,x_sim] = ode23tb(@(t,x) F_force(t,x,w_0),[0 3*Npers*2*pi/w_0], x_sim(:,end));
    t_sim = t_sim'; x_sim = x_sim';
    figure
    plot(t_sim,x_sim(outdof,:))
    
    w_sweep = 32:.1:35;
    u_sweep = zeros(1,length(w_sweep)); x_sim_i = x_sim;
    [~,x_PO] = ode23tb(@(t,x) F_force(t,x,w_0),[0 1*2*pi/w_0], x_sim_i(:,end));
    u_sweep(1) = max(abs(x_PO(:,outdof)));
    Npers = 30;
    
    for ii = 2:length(w_sweep)
        ii
        [~,x_sim_i] = ode23tb(@(t,x) F_force(t,x,w_sweep(ii)),[0 Npers*2*pi/w_sweep(ii)], x_sim_i(:,end));
        x_sim_i = x_sim_i';
        [~,x_PO] = ode23tb(@(t,x) F_force(t,x,w_sweep(ii)),[0 1*2*pi/w_sweep(ii)], x_sim_i(:,end));
        u_sweep(ii) = max(abs(x_PO(:,outdof)));
    end
    
    DataInfo = struct('nElements',nElements,'IC_loadvector',loadvector,'FRC_force',f_veci*f_full(jj),'FRC_ampcoord',outdof);
    FullTrajectories = xData;
    FRC_NI = struct('omega',w_sweep,'amp',u_sweep);
    save('data_VKcc.mat','DataInfo','FullTrajectories','FRC_NI')
end
%%
figure(100);
plot(FRC_NI.omega,FRC_NI.amp,'c.','MarkerSize',24,'DisplayName','Numerical integration')
