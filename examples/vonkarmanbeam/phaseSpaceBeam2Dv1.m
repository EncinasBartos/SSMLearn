%% Finding a 2D SSM for a von K치rm치n beam
% This is an example of how to reconstruct a slow 2D SSM of a mechanical  
% system using all phase space variables measurements. In this example, we 
% consider the clamped-clamped von K치rm치n beam discussed in [1].
% 
% 
% 
% [1] Jain, S., Tiso, P. & Haller, G. (2017). Exact Nonlinear Model Reduction 
% for a von Karman beam: Slow-Fast Decomposition and Spectral Submanifolds. Journal 
% of Sound and Vibration. 423. 10.1016/j.jsv.2018.01.049. 

clearvars
close all
format shortg
clc
%% Example setup
% The $N$-degree of freedom dynamical system is of the form
% 
% $$\mathbf{M\ddot{q}} + \mathbf{C\dot{q}} + \mathbf{Kq} + \mathbf{f}(\mathbf{q},\mathbf{\dot{q}}) 
% = \mathbf{0}$$
% 
% where $\mathbf{f}=\mathcal{O}(|\mathbf{q}|^2,|\mathbf{\dot{q}}|^2,|\mathbf{q}||\mathbf{\dot{q}}|)$ 
% represents the nonlinearities and $\mathbf{M}$, $\mathbf{C}$, and $\mathbf{K}$ 
% are the $n\times n$ mass, stiffness, and damping matrices, respectively.
% 
% We rewrite the system in first-order form as
% 
% $$\mathbf{\dot{x}} = \mathbf{A}\mathbf{x} + \mathbf{G}(\mathbf{x}) = \mathbf{F}(\mathbf{x})$$
% 
% with
% 
% $\mathbf{x}=\left[\begin{array}{c}\mathbf{q}\\\dot{\mathbf{q}}\end{array}\right],\quad\mathbf{A}=\left[\begin{array}{cc}\mathbf{0}  
% & \mathbf{I}\\-\mathbf{M}^{-1}\mathbf{K} & -\mathbf{M}^{-1}\mathbf{C} \end{array}\right],\quad\mathbf{G}(\mathbf{x})=\left[\begin{array}{c}  
% \mathbf{0} \\ -\mathbf{M}^{-1}\mathbf{f}(\mathbf{x})\end{array}\right]$.

nElements = 12;
[M, C, K, fnl, fExt, outdof, PlotFieldonDefMesh] = buildModel(nElements);
n = size(M,1);    % mechanical dofs (axial def, transverse def, angle)
[F, lambda] = functionFromTensors(M, C, K, fnl); d_r1 = -real(lambda(1))/abs(lambda(1))*100
% Conservative mode shapes
[W,A,V] = linearpart(M,C,K); % figure; spy(abs(W*A*V)>1e-4)

%% Define SSM dimension, displacement to track and forcing shape

% Note: we assume that amplitude and forcing are strongly related to the
% SSM under evaluation

% Slow SSM dimension and its tangent space
sSSMDim = 2;
Ve = V(:,1:sSSMDim); % Mode shape
We = W(1:sSSMDim,:); % Projection to mode shape
Ae = We*A*Ve % Reduced, linearized dynamics

% Load and displacement vector: midpoint displacement
displacementVector = zeros(1,n); displacementVector(outdof) = 1;
loadVector = zeros(n,1); loadVector(outdof) = 1;  %  could also be set as modal ones
%% Static analysis to evaluate lin. vs nonlin. response

loadCoefficients = [0.01:0.01:0.09 0.1:0.1:0.9 1:1:10 12 14 15]*1e3;
nLoads = length(loadCoefficients);
wlin = (K\loadVector);
w0 = loadCoefficients(1)*wlin; % linear initial guess
displacementLinear = loadCoefficients*(displacementVector*wlin);
IC = zeros(2*n,nLoads); displacementNonlinear = zeros(1,nLoads);
options = optimoptions('fsolve', 'MaxFunctionEvaluations', 200*n, 'Display', 'off');
for iLoad = 1:nLoads
    f_eq = @(w)([zeros(n) M]*F(0,[w; zeros(n,1)]) + loadVector*loadCoefficients(iLoad));
    [w0, ~, exitflag, output] = fsolve(f_eq, w0, options);
    if exitflag <= 0
        error('Warning: No solution found for loading configuration')
    end
    IC(:,iLoad) = [w0; zeros(n,1)]; displacementNonlinear(iLoad) = displacementVector*w0;
end

customFigure(); classicColors = colororder;
plot(displacementLinear,loadCoefficients/1e3,'k--','Linewidth',1,'DisplayName','Linear')
plot(displacementNonlinear,loadCoefficients/1e3,'Color',classicColors(1,:),'Linewidth',2,'DisplayName','Nonlinear')
legend('location','SE')
xlim(abs([displacementNonlinear([1 end])]))
xlabel('displacement'); 
ylabel('force'); 
title('Static loading analysis');
drawnow;

customFigure(); classicColors = colororder;
displacementDifference = abs((displacementNonlinear-displacementLinear))./abs(displacementLinear);
plot(displacementDifference*100,loadCoefficients/1e3,'Color',classicColors(1,:),'Linewidth',2)
xlim([0 max(displacementDifference)]*100)
xlabel('relative displacement difference %'); 
ylabel('force'); 
title('Linear vs. Nonlinear')
drawnow;
% Pick up two initial trajectories that has high expected nonlinear content
indNonlinIC = length(loadCoefficients) - [1 2];
IC = IC(:,indNonlinIC);
indTest = 1;
indTrain = 2;
%%
% Define the linear regime at 0.05 % relative displacement
linearDisplacementReference = displacementNonlinear(sum(displacementDifference<(0.05/100))+1);
nonlinearDisplacementReference = max(displacementNonlinear(indNonlinIC));
desiredAmpltitudeDecay = nonlinearDisplacementReference/linearDisplacementReference;
%% 
% The data is generated by time-integration of the right-hand side of the system. 
% 
% To save execution time and avoid rerunning the simulation, |newMeasurement| 
% can be set to |false|.

newMeasurement = true;
observable = @(x) x; % Observe the full phase space
slowTimeScale = 2*pi/abs(lambda(1));
fastTimeScale = 2*pi/abs(lambda(round(sSSMDim/2)));
if newMeasurement
    % Set integration time to get approximately the desired ampltiude decay
    % to get to the linear regime (guess based on linearized damping)
    numberPeriodsSlow = floor(log(desiredAmpltitudeDecay)/...
        (2*pi*(-real(lambda(1))/abs(lambda(1)))))
    endTime = numberPeriodsSlow*slowTimeScale;
    % Set the sampling time to capture approximately 100 points per period 
    % on the faster time scale
    numberPeriodsFast = floor(endTime/fastTimeScale);
    numberPointsPerPeriod = 100;
    nSamp = numberPeriodsFast*numberPointsPerPeriod+1;
    dt = endTime/(nSamp-1);
    % Integrate
    xData = integrateTrajectories(F, endTime, IC, nSamp, observable);
    DataInfo = struct('nElements', nElements, 'loadvector', loadVector);
    save('dataVKDecay2D.mat', 'DataInfo', 'xData', 'dt', 'endTime', 'nSamp')
else
    load dataVKDecay2D.mat
    if nElements ~= DataInfo.nElements
       error('The loaded data comes from a model with a different number of elements.') 
    end
end

%% Phase space embedding

sSSMDim = 2;
yData = coordinatesEmbedding(xData, sSSMDim, 'ForceEmbedding', 1);

% Data filtering
% We need to make sure that the data that we use to identify the slow manifold 
% lies close to it. We can do this by plotting a spectrogram of the beam tip displacement. 
% In general, there may be many vibratory modes present at first, but the faster 
% ones quickly die out.

showSpectrogram(yData(indTrain,:), outdof);
ylim([0,abs(lambda(1))/2/pi*5])
 
% We plot the tip displacement over time for closer inspection. 

customFigure();
plot(xData{1,1}, xData{1,2}(outdof,:), xData{2,1}, xData{2,2}(outdof,:), ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); ylabel('$u \, [$m$]$','Interpreter','latex'); 
legend({'Trajectory 1', 'Trajectory 2'})
title('Generated data')
% 
% Next, we use the information from the spectrogram and plot to remove the first 
% part of the training data. After the first few oscillations have passed, there 
% is one dominant mode left in the frequency spectrum. In this case, faster modes 
% die out very quickly, so we can use almost all of the data. We must however 
% remove the first transient to fulfill the assumption that trajectories lie close 
% to the SSM. We keep only the time interval |sliceInt|.

sliceInt = [4*slowTimeScale, endTime];
yDataTrunc = sliceTrajectories(yData, sliceInt);

%% Datadriven manifold fitting
% The measured trajectories are assumed to lie close to a two-dimensional manifold 
% that is tangent at the origin to the eigenspace corresponding to the slowest 
% pair of eigenvalues. We now want to fit a polynomial of order $M$ to the data 
% points to approximate the manifold. Here we use a graph style parametrization, 
% meaning that the manifold is parametrized using coordinates in the computed 
% eigenspace $V_e$. This excludes the possibility of folds on the manifold (however, 
% if necessary we may circumvent this problem by increasing the dimensionality 
% of the observed space). 
% 
% 
% 
% We seek the $2n\times m_M$ polynomial coefficient matrix $H$ of the manifold 
% on the form
% 
% $y = V_e V_e^\top y + H \phi_{m,2:M}(V_e^\top y)$,
% 
% where the function $\phi_{m,2:M}(q)$ computes a vector of all $m_M$ monomials 
% from orders 2 up to $M$ of an $m$-vector $q$. This optimization problem is formulated 
% as the minimization of a cost function computed from the measured data $y_k$,
% 
% $$C_r(H) = \sum_{k=1}^N ||y_k - V_eV_e^\top y_k - H\phi_{m,2:M}(V_e^\top 
% y_k) ||$$.

% Get projection or modal coordinates 
etaData = yData;
etaDataTrunc = yDataTrunc;
for iTraj = 1:size(yData,1)
    etaData{iTraj,2} = We*yData{iTraj,2};
    etaDataTrunc{iTraj,2} = We*yDataTrunc{iTraj,2};
    
end
plotReducedCoordinates(etaData);
legend({'Test set trajectory', 'Training set trajectory'})

% Compute nonlinear part of the parametrization
SSMOrder = 3;
IMInfo = IMGeometry(yDataTrunc(indTrain,:), sSSMDim,SSMOrder,...
         'reducedCoordinates',etaDataTrunc(indTrain,:),'Ve',Ve); 
IMInfo.chart.map = @(x) We*x;                          

% Parametrization error on test trajectory
normedTrajDist = computeTrajectoryErrors(liftTrajectories(IMInfo,...
    etaDataTrunc), yDataTrunc);
staticNMTE = mean(normedTrajDist(indTest))*100 % in percentage
%% Plot SSM
idxPlot = [outdof+2]; % 3D Plot: eta_1, eta_2 and idxPlot coordinate
plotSSMandTrajectories(IMInfo, idxPlot, yDataTrunc(indTest,:), etaDataTrunc(indTest,:))
view(-100,20); legend('off')
idxPlot = [outdof outdof+n outdof-4]; % 3D Plot: idxPlot(1), idxPlot(2), idxPlot(3) coordinates
plotSSMandTrajectories(IMInfo, idxPlot, yDataTrunc(indTest,:), etaDataTrunc(indTest,:))
view(-100,20); legend('off')
gPlot = @(x) W(5,:)*x; % 3D Plot: eta_1, eta_2 and gPlot(x) 
plotSSMandTrajectories(IMInfo, gPlot, yDataTrunc(indTest,:), etaDataTrunc(indTest,:))
view(-100,20); legend('off')
gPlot = @(x) W([5 6 15],:)*x; % 3D Plot with the three values of gPlot(x) 
plotSSMandTrajectories(IMInfo, gPlot, yDataTrunc(indTest,:), etaDataTrunc(indTest,:))
view(-100,20); legend('off')

%% Reduced order model
% We compute a model for the reduced dynamics with the truncated training data 
% projected onto the manifold. The function |IMDynamicsFlow| fits a polynomial 
% map = 
% 
% $$\dot{\eta} = W_r \phi(\eta)$$
% 
% where $\phi(\eta)$ again computes a vector of all monomials of $\eta$, and  
% $W_r$ is a matrix of polynomial coefficients. 
% 
% We are also specifying that we want the reduced dynamics on a normal form, 
% and seek the Taylor expansion of a map $N$ fulfilling
% 
% $$\dot{z} = N(z) =Dz + W_n\phi(z)$$
% 
% with $D$ a diagonal matrix and $W_n$ containing coefficients for the near-resonant 
% nonlinear terms, after a near-identity change of coordinates
% 
% $$z = T^{-1}(\eta) = \eta + W_t \phi(\eta)$$
% 
% with $W_t$ containing the coefficients for the nonlinear terms of the coordinate 
% change. Here we fix the linear part.

ROMOrder = 7;
RDInfo = IMDynamicsMech(etaDataTrunc(indTrain,:), ...
    'R_PolyOrd', 1,'N_PolyOrd', ROMOrder, 'style', 'normalform','R_coeff',Ae,'rescale',1);
%%
% We transform the truncated initial condition of our test trajectory according 
% to the obtained change of coordinates, and integrate our reduced order evolution 
% rule to predict the development of the trajectory. 

[yRec, etaRec, zRec] = advect(IMInfo, RDInfo, yDataTrunc);
% Evaluation of reduced dynamics
% The error NMTE is computed as the average distance of the predicted trajectory 
% to the measured one in the full state space.

normedTrajDist = computeTrajectoryErrors(yRec, yDataTrunc);
NMTE = mean(normedTrajDist(indTest))
%
% We plot the true test set trajectory in the reduced coordinates and compare 
% it to the prediction. 

plotReducedCoordinates(etaDataTrunc(indTest,:), etaRec(indTest,:))
legend({'Test set (truncated)', 'Prediction'})
%
% We also plot the measured and predicted tip displacement. The reduced model 
% seems to do well on previously unseen data, provided that it is close to the 
% 2D manifold.

plotTrajectories(yData(indTest,:), yRec(indTest,:), 'm','PlotCoordinate', outdof, 'DisplayName', {'Test set', 'Prediction'})
ylabel('$u \, [$m$]$','Interpreter','latex')

% Plot SSM with trajectories in the normal form reduced coordinates
plotSSMandTrajectories(IMInfo, outdof, yDataTrunc(indTest,:), ...
    zRec(indTest,:), 'NFT', RDInfo.transformation.map)
view(-100,20); legend('off')
%% Backbone curves
% With the knowledge of the coefficients of the normal form, we extract backbone 
% curves for the instantaneous damping and frequency. 
%
zData = transformTrajectories(RDInfo.inverseTransformation.map, etaData);
rhoCal = abs(zData{indTrain(1),2}(1,1));
amplitudeFunction = @(x) x(outdof,:);
figure
BBCInfo = backboneCurves(IMInfo, RDInfo, amplitudeFunction, rhoCal);
subplot(121); ylabel('$u \, [$m$]$','Interpreter','latex')
subplot(122); ylabel('$u \, [$m$]$','Interpreter','latex')
iTraj = 1;
% Compare with backbone curve from signal processing
[amp,freq,~,~] = PFF(yDataTrunc{iTraj,1},amplitudeFunction(yDataTrunc{iTraj,2}));
plot(freq*2*pi,amp,':','Linewidth',2)
legend('SSMLearn ROM','Peak Finding & Fitting')
%% Generate Frequency Responses

amplitudeCal = [0.005 0.01]; forcingNormalForm = amplitudeCal;
for iCal = 1:length(amplitudeCal)
   [~,pos] = min(abs(BBCInfo.amplitude-amplitudeCal(iCal)));
   forcingNormalForm(iCal) = -BBCInfo.amplitudeNormalForm(pos)*BBCInfo.damping(pos);
end

FRCData = analyticalFRC(IMInfo, RDInfo, forcingNormalForm, amplitudeFunction,0.011);

% Modal forcing level in the full system converted to physical forcing
rescale_lin = RDInfo.transformation.lintransf(1,1);
forcingRatio = 4*rescale_lin*abs(imag(lambda(1))) / ...
              (transpose(V(1:n,1))*loadVector);      
omegaSpan = abs(imag(lambda(1)))*[0.9 1.3];
FRCSSMTool = SSMToolFRCcustom(M, C, K, fnl, loadVector, forcingRatio*forcingNormalForm, outdof, omegaSpan, ROMOrder,2e3);
   
%% FRC plot and evaluation
%
customFigure(); colors = colororder;
plotFRC(FRCData, colors(5,:), '- SSMLearn','y', 'Phase','freqscale',2*pi)
plotFRC(FRCSSMTool, colors(3,:), '- SSMTool','y', 'Phase','freqscale',2*pi)
xlabel('forcing frequency [Hz]')
ylabel('phase')
set(gca, 'FontSize', 18)
xlim([95 130])
legend('off')
customFigure(); 
plot(BBCInfo.frequency/2/pi, BBCInfo.amplitude,'Color',colors(1,:),'Linewidth',2,'DisplayName', 'Backbone - SSMLearn')
plotFRC(FRCData, colors(5,:), '- SSMLearn','freqscale',2*pi)
plotFRC(FRCSSMTool, colors(3,:), '- SSMTool','freqscale',2*pi)
xlabel('forcing frequency [Hz]')
ylabel('displacement [m]')
set(gca, 'FontSize', 18)
xlim([95 130])
ylim([0 0.012])
legend('location','E')